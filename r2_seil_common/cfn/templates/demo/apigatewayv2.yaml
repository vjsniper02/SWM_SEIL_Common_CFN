AWSTemplateFormatVersion: "2010-09-09"

Description: |
  Creates an API backed by a dummy Lambda function. Creates an API authorizer to protect the API from anonymous access.
  The authorizer is backed by a Cognito user pool and supports client credential OAuth flow.
  The API gateway accesses the Lambda through an internal ALB integration via a VPC link.
  The ALB listener is on Port 443 with a certificate from the ACM, issued to a private hosted zone record.
  A WAF WebACL is associated with the ALB.

Parameters:
  AccountPrefix:
    Description: Account Name as Prefix
    Type: AWS::SSM::Parameter::Value<String>
    Default: /account/name
  EnvPrefix:
    Type: String
    Description: Environment Name as Prefix
    Default: dev
  ProjPrefix:
    Type: AWS::SSM::Parameter::Value<String>
    Description: resource prfix, swmi
    Default: ProjPrefix
  ApiName:
    Type: String
    Default: forecast
  APIDNS:
    Type: String
    Default: swmi-dev.com
  BasePath:
    Type: String
    Default: v1

Resources:
  Api:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Body:
        'Fn::Transform':
          Name: 'AWS::Include'
          Parameters:
            Location: s3://swmi-dev-sourcecode/openapi-specs/openapi-oas30-apigwv2.yaml

  Stage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref Api
      AutoDeploy: true
      StageName: !Ref EnvPrefix

  UserPool:
    Type: AWS::Cognito::UserPool

  UserPoolClient202203:
    Type: AWS::Cognito::UserPoolClient
    DependsOn: UserPoolResourceServer
    Properties:
      AllowedOAuthFlows:
      - client_credentials
      AllowedOAuthFlowsUserPoolClient: true
      AllowedOAuthScopes:
      # UserPoolResourceServer.Identifier/ScopeName
      - !Sub ${ProjPrefix}-${EnvPrefix}-oauth-rs/get
      - !Sub ${ProjPrefix}-${EnvPrefix}-oauth-rs/post
      ClientName: !Sub ${EnvPrefix}-${ApiName}-userpoolclient-202203
      ExplicitAuthFlows:
      - ALLOW_REFRESH_TOKEN_AUTH
      GenerateSecret: true
      SupportedIdentityProviders:
      - COGNITO
      UserPoolId: !Ref UserPool

  UserPoolDomain:
    Type: AWS::Cognito::UserPoolDomain
    Properties:
      Domain: !Sub swmi-dev-oauth-v2
      UserPoolId: !Ref UserPool

  UserPoolResourceServer:
    Type: AWS::Cognito::UserPoolResourceServer
    Properties:
      Identifier: !Sub ${ProjPrefix}-${EnvPrefix}-oauth-rs
      Name: !Sub ${ProjPrefix}-${EnvPrefix}-resource-server
      # Dummy scopes for now
      Scopes:
      - ScopeDescription: GET scope
        ScopeName: get
      - ScopeDescription: POST scope
        ScopeName: post
      UserPoolId: !Ref UserPool

  ForecastRouterServiceLambdaInvoke:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt Lambda.Arn
      Principal: apigateway.amazonaws.com
      # arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${Api}/STAGE_NAME/HTTP_METHOD/ROUTE
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${Api}/${EnvPrefix}/POST/forecast

  LambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Action:
          - sts:AssumeRole
          Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
        Version: 2012-10-17
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/AWSLambdaExecute
      - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole

  # This is a dummy Lamdda function to facilitate testing
  Lambda:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          exports.handler = function(event, context) {
            console.log("REQUEST RECEIVED:\n" + JSON.stringify(event))
            let response = {
              statusCode: 200,
              body: JSON.stringify(event),
              headers: {
                'Content-Type': 'application/json',
              }
            };
            context.succeed(response);
          }
      Handler: index.handler
      Role: !GetAtt LambdaRole.Arn
      Runtime: nodejs14.x
      VpcConfig:
        SecurityGroupIds:
        - !GetAtt LambdaSg.GroupId
        SubnetIds:
        - "{{resolve:ssm:/networking/privatesubnet1/id}}"
        - "{{resolve:ssm:/networking/privatesubnet2/id}}"
        - "{{resolve:ssm:/networking/privatesubnet3/id}}"

  LambdaSg:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Does not need ingress rule to work
      VpcId: "{{resolve:ssm:/networking/vpc/id}}"

  LambdaSgId:
    Type: AWS::SSM::Parameter
    Properties:
      Description: !Sub ${EnvPrefix}-${ApiName} Lambda function security group ID
      Name: !Sub /${EnvPrefix}/sg/${ApiName}-lambda-sg
      Type: String
      Value: !GetAtt LambdaSg.GroupId

  Alb:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Scheme: internal
      SecurityGroups:
      - !GetAtt AlbSg.GroupId
      Subnets:
      - "{{resolve:ssm:/networking/privatesubnet1/id}}"
      - "{{resolve:ssm:/networking/privatesubnet2/id}}"
      - "{{resolve:ssm:/networking/privatesubnet3/id}}"
      Type: application

  AlbSg:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Allow ingress on Port 443 from VPC link
      SecurityGroupIngress:
      - FromPort: 443
        IpProtocol: tcp
        SourceSecurityGroupId: !GetAtt VpcLinkSg.GroupId
        ToPort: 443
      VpcId: "{{resolve:ssm:/networking/vpc/id}}"

  VpcLink:
    Type: AWS::ApiGatewayV2::VpcLink
    Properties:
      Name: !Sub ${EnvPrefix}-${Lambda}-vpclink
      SecurityGroupIds:
      - !GetAtt VpcLinkSg.GroupId
      SubnetIds:
      - "{{resolve:ssm:/networking/privatesubnet1/id}}"
      - "{{resolve:ssm:/networking/privatesubnet2/id}}"
      - "{{resolve:ssm:/networking/privatesubnet3/id}}"

  VpcLinkSg:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Does not need ingress rule to work
      VpcId: "{{resolve:ssm:/networking/vpc/id}}"

  AlbListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      Certificates:
      - CertificateArn: !Ref AlbCert
      DefaultActions:
      - TargetGroupArn: !Ref LambdaTg
        Type: forward
      LoadBalancerArn: !Ref Alb
      Port: 443
      Protocol: HTTPS
      SslPolicy: ELBSecurityPolicy-FS-1-2-Res-2020-10

  LambdaTg:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    DependsOn: AlbLambdaInvokePermission
    Properties:
      Name: !Sub ${EnvPrefix}-${ApiName}-tg
      Targets:
      - Id: !GetAtt Lambda.Arn
      TargetType: lambda

  AlbLambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt Lambda.Arn
      Principal: elasticloadbalancing.amazonaws.com
      # Hardcode the Lambda TG Arn to avoid circular dependency between this Permission and LambdaTg
      SourceArn: !Sub arn:aws:elasticloadbalancing:${AWS::Region}:${AWS::AccountId}:targetgroup/${EnvPrefix}-${ApiName}-tg/*

  AlbR53DnsRecordSetGroup:
    Type: AWS::Route53::RecordSetGroup
    Properties:
      HostedZoneId: "{{resolve:ssm:/networking/route53/id}}"
      RecordSets:
      - AliasTarget:
          DNSName: !GetAtt Alb.DNSName
          EvaluateTargetHealth: false
          HostedZoneId: !GetAtt Alb.CanonicalHostedZoneID
        Name: !Sub "${ApiName}.{{resolve:ssm:/networking/route53/zonename}}"
        Type: A

  AlbCert:
    Type: AWS::CertificateManager::Certificate
    Properties:
      DomainName: !Sub "${ApiName}.{{resolve:ssm:/networking/route53/zonename}}"
      DomainValidationOptions:
      - DomainName: !Sub "${ApiName}.{{resolve:ssm:/networking/route53/zonename}}"
        HostedZoneId: "{{resolve:ssm:/networking/route53/id}}"
      ValidationMethod: DNS

  # WAF
  WafWebAcl:
    Type: AWS::WAFv2::WebACL
    Properties:
      DefaultAction:
        Allow: {}
      Description: "Forecast API WAF WebACL"
      # Name: "String" # TODO: name?
      Rules:
        - Name: AWSManagedRulesCommonRule # TODO: rename?
          OverrideAction:
            None: {}
          Priority: 0
          Statement:
            ManagedRuleGroupStatement:
              Name: AWSManagedRulesCommonRuleSet
              VendorName: AWS
          VisibilityConfig:
            CloudWatchMetricsEnabled: false
            MetricName: "FooBar" # Placeholder; CW is disabled for now so this is sort of irrelevant
            SampledRequestsEnabled: false
        - Name: AWSManagedRulesKnownBadInputsRule # TODO: rename?
          OverrideAction:
            None: {}
          Priority: 10
          Statement:
            ManagedRuleGroupStatement:
              Name: AWSManagedRulesKnownBadInputsRuleSet
              VendorName: AWS
          VisibilityConfig:
            CloudWatchMetricsEnabled: false
            MetricName: "FooBar" # Placeholder; CW is disabled for now so this is sort of irrelevant
            SampledRequestsEnabled: false
      Scope: REGIONAL
      VisibilityConfig:
        CloudWatchMetricsEnabled: false
        MetricName: "FooBar" # Placeholder; CW is disabled for now so this is sort of irrelevant
        SampledRequestsEnabled: false

  WafWebAclAssociation:
    Type: AWS::WAFv2::WebACLAssociation
    Properties:
      ResourceArn: !Ref Alb
      WebACLArn: !GetAtt WafWebAcl.Arn

Outputs:
  UserPoolId:
    Description: User Pool ID
    Value: !Ref UserPool

  UserPoolClientId:
    Description: User Pool Client ID
    Value: !Ref UserPoolClient202203

  CmdGetUserPoolClientSecret:
    Description: AWS CLI command to get the User Pool Client Secret
    Value: !Sub aws cognito-idp describe-user-pool-client --region ${AWS::Region} --user-pool-id ${UserPool} --client-id ${UserPoolClient202203} --query UserPoolClient.ClientSecret --output text

  ApiBaseUrl:
    Description: API Gateway base URL
    Value: !GetAtt Api.ApiEndpoint

  AccessTokenUrl:
    Description: URL to get access token
    Value: !Sub https://${UserPoolDomain}.auth.${AWS::Region}.amazoncognito.com/oauth2/token